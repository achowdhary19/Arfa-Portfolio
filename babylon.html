<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>Babylon Template</title>

  <style>
    html,
    body {
      overflow: hidden;
      width: 100%;
      height: 100%;
      margin: 0;
      padding: 0;
    }

    #renderCanvas {
      width: 100%;
      height: 100%;
      touch-action: none;
    }
  </style>

<!-- <meta name = "viewport" content= "width=device-width, initial-scale=1, shrink-to-fit=no" /> -->
<title> babylon</title>
<link rel="stylesheet" href="style.css">
<!-- <script src="https://cdn.babylonjs.com/viewer/babylon.viewer.js"></script>   -->

<script src="earcut.min.js"></script>

  <script src="https://cdn.babylonjs.com/babylon.js"></script>
  <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
  <script src="https://code.jquery.com/pep/0.4.3/pep.js"></script>
</head>

<body>
    <div id = "babylon-holder">
        <canvas id="renderCanvas" touch-action="none"></canvas>
    </div>

    <div id = "instructions">
        <br/>
        <h2>BABYLON</h2>
        <br/>
        <!-- <p>
            babylon...
        </p>
        -->
    </div>


  <!-- touch-action="none" for best results from PEP -->
  <script>
    const canvas = document.getElementById("renderCanvas"); // Get the canvas element
    const engine = new BABYLON.Engine(canvas, true); // Generate the BABYLON 3D engine

    // Add your code here matching the playground format
    const createScene = function () {
      const scene = new BABYLON.Scene(engine);

      const material = new BABYLON.StandardMaterial("name", scene);

      const box = BABYLON.MeshBuilder.CreateBox("box", {});
      box.position.y = .5;  //box created with default size so height is 1
      box.position.x = 5.2; 

      box.scaling = new BABYLON.Vector3(2, 1.5, 3);
      const boxMat = new BABYLON.StandardMaterial("boxMat");
      boxMat.diffuseTexture = new BABYLON.Texture("https://assets.babylonjs.com/textures/crate.png", scene);
      box.material = boxMat;


        
    //creating ground
      const ground = BABYLON.MeshBuilder.CreateGround("ground", {width:10, height:10});
      //creating ground material 
ground.position.y = -.25; 
ground.position.x = .75; 
      const groundMat = new BABYLON.StandardMaterial("groundMat");
      groundMat.diffuseTexture = new BABYLON.Texture("https://assets.babylonjs.com/textures/grass.jpg", scene);
      ground.material = groundMat; //Place the material property of the ground






      
    //    meshChild.parent = meshParent
        //base
         const outline = [
             new BABYLON.Vector3(-0.3, 0, -0.1),
             new BABYLON.Vector3(0.2, 0, -0.1),
         ]

        //curved front
        for (let i = 0; i < 20; i++) {
            outline.push(new BABYLON.Vector3(0.2 * Math.cos(i * Math.PI / 40), 0, 0.2 * Math.sin(i * Math.PI / 40) - 0.1));
        }

        //top
        outline.push(new BABYLON.Vector3(0, 0, 0.1));
        outline.push(new BABYLON.Vector3(-0.3, 0, 0.1));

        const car = BABYLON.MeshBuilder.ExtrudePolygon("car", {shape: outline, depth: 0.2});
        car.rotation.x = 4.7; 
        //car.rotation.y = 5; 
        
    const faceUV = [];
    faceUV[0] = new BABYLON.Vector4(0, 0.5, 0.38, 1);
    faceUV[1] = new BABYLON.Vector4(0, 0, 1, 0.5);
    faceUV[2] = new BABYLON.Vector4(0.38, 1, 0, 0.5);

    //material
    const carMat = new BABYLON.StandardMaterial("carMat");
    carMat.diffuseTexture = new BABYLON.Texture("https://assets.babylonjs.com/environments/car.png");

    car.material = carMat;



    //wheel face UVs
    const wheelUV = [];
    wheelUV[0] = new BABYLON.Vector4(0, 0, 1, 1);
    wheelUV[1] = new BABYLON.Vector4(0, 0.5, 0, 0.5);
    wheelUV[2] = new BABYLON.Vector4(0, 0, 1, 1);
    
    //wheel material
    const wheelMat = new BABYLON.StandardMaterial("wheelMat");
    wheelMat.diffuseTexture = new BABYLON.Texture("https://assets.babylonjs.com/environments/wheel.png");

    const wheelRB = BABYLON.MeshBuilder.CreateCylinder("wheelRB", {diameter: 0.125, height: 0.05, faceUV: wheelUV})
    wheelRB.material = wheelMat;
    wheelRB.parent = car;
    wheelRB.position.z = -0.1;
    wheelRB.position.x = -0.2;
    wheelRB.position.y = 0.035;

    wheelRF = wheelRB.clone("wheelRF");
    wheelRF.position.x = 0.1;

    wheelLB = wheelRB.clone("wheelLB");
    wheelLB.position.y = -0.2 - 0.035;

    wheelLF = wheelRF.clone("wheelLF");
    wheelLF.position.y = -0.2 - 0.035;

    
    const animWheel = new BABYLON.Animation("wheelAnimation", "rotation.y", 30, BABYLON.Animation.ANIMATIONTYPE_FLOAT, BABYLON.Animation.ANIMATIONLOOPMODE_CYCLE);
    const wheelKeys = []; 

    //At the animation key 0, the value of rotation.y is 0
    wheelKeys.push({
        frame: 0,
        value: 0
    });

    //At the animation key 30, (after 1 sec since animation fps = 30) the value of rotation.y is 2PI for a complete rotation
    wheelKeys.push({
        frame: 30,
        value: 2 * Math.PI
    });
    
    //set the keys
    animWheel.setKeys(wheelKeys);

    //Link this animation to the right back wheel
    wheelRB.animations = [];
    wheelRB.animations.push(animWheel);

    //Begin animation - object to animate, first frame, last frame and loop if true
    scene.beginAnimation(wheelRB, 0, 30, true);
    scene.beginAnimation(wheelRF, 0, 30, true);
    scene.beginAnimation(wheelLB, 0, 30, true);
    scene.beginAnimation(wheelLF, 0, 30, true);

//     BABYLON.SceneLoader.ImportMeshAsync("", "url to model car", "car.babylon").then(() =>  {
//     const wheelRB = scene.getMeshByName("wheelRB");
//     const wheelRF = scene.getMeshByName("wheelRF");
//     const wheelLB = scene.getMeshByName("wheelLB");
//     const wheelLF = scene.getMeshByName("wheelLF");

//     scene.beginAnimation(wheelRB, 0, 30, true);
//     scene.beginAnimation(wheelRF, 0, 30, true);
//     scene.beginAnimation(wheelLB, 0, 30, true);
//     scene.beginAnimation(wheelLF, 0, 30, true);
// });



const animCar = new BABYLON.Animation("carAnimation", "position.x", 30, BABYLON.Animation.ANIMATIONTYPE_FLOAT, BABYLON.Animation.ANIMATIONLOOPMODE_CYCLE);

const carKeys = []; 

carKeys.push({
    frame: 0,
    value: -4
});

carKeys.push({
    frame: 150,
    value: 4
});

carKeys.push({
    frame: 210,
    value: 4
});

animCar.setKeys(carKeys);

car.animations = [];
car.animations.push(animCar);

scene.beginAnimation(car, 0, 210, true);

    //new colors 
    new BABYLON.Color3.Red();
    new BABYLON.Color3.Green();
    new BABYLON.Color3.Blue();
    new BABYLON.Color3.Black();
    new BABYLON.Color3.White();
    new BABYLON.Color3.Purple();
    new BABYLON.Color3.Magenta();
    new BABYLON.Color3.Yellow();
    new BABYLON.Color3.Gray(),
    new BABYLON.Color3.Teal();

      const camera = new BABYLON.ArcRotateCamera("camera", -Math.PI / 2, Math.PI / 2.5, 15, new BABYLON.Vector3(0, 0, 0));
      camera.attachControl(canvas, true);
      const light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(1, 1, 0));

      return scene;
    };

    const scene = createScene(); //Call the createScene function

    // Register a render loop to repeatedly render the scene
    engine.runRenderLoop(function () {
      scene.render();
    });

    // Watch for browser/canvas resize events
    window.addEventListener("resize", function () {
      engine.resize();
    });
  </script>
</body>
</html>




